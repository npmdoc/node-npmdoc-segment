<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/leizongmin/node-segment#readme"

    >segment (v0.1.3)</a>
</h1>
<h4>Chinese word segmentation 中文分词模块</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment">module segment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.segment">
            function <span class="apidocSignatureSpan"></span>segment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Optimizer">
            function <span class="apidocSignatureSpan">segment.</span>Optimizer
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment">
            function <span class="apidocSignatureSpan">segment.</span>Segment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Tokenizer">
            function <span class="apidocSignatureSpan">segment.</span>Tokenizer
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>ChsNameOptimizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>ChsNameTokenizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>DatetimeOptimizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>DictOptimizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>DictTokenizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>EmailOptimizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>ForeignTokenizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>Optimizer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>POSTAG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>PunctuationTokenizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>Segment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>SingleTokenizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>Tokenizer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>URLTokenizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.</span>WildcardTokenizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.ChsNameOptimizer">module segment.ChsNameOptimizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.ChsNameOptimizer.doOptimize">
            function <span class="apidocSignatureSpan">segment.ChsNameOptimizer.</span>doOptimize
            <span class="apidocSignatureSpan">(words)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.ChsNameOptimizer.init">
            function <span class="apidocSignatureSpan">segment.ChsNameOptimizer.</span>init
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.ChsNameOptimizer.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.ChsNameTokenizer">module segment.ChsNameTokenizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.ChsNameTokenizer.init">
            function <span class="apidocSignatureSpan">segment.ChsNameTokenizer.</span>init
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.ChsNameTokenizer.split">
            function <span class="apidocSignatureSpan">segment.ChsNameTokenizer.</span>split
            <span class="apidocSignatureSpan">(words)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.ChsNameTokenizer.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.DatetimeOptimizer">module segment.DatetimeOptimizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.DatetimeOptimizer.doOptimize">
            function <span class="apidocSignatureSpan">segment.DatetimeOptimizer.</span>doOptimize
            <span class="apidocSignatureSpan">(words, is_not_first)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.DatetimeOptimizer.init">
            function <span class="apidocSignatureSpan">segment.DatetimeOptimizer.</span>init
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.DatetimeOptimizer.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.DictOptimizer">module segment.DictOptimizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.DictOptimizer.doOptimize">
            function <span class="apidocSignatureSpan">segment.DictOptimizer.</span>doOptimize
            <span class="apidocSignatureSpan">(words, is_not_first)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.DictOptimizer.init">
            function <span class="apidocSignatureSpan">segment.DictOptimizer.</span>init
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.DictOptimizer.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.DictTokenizer">module segment.DictTokenizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.DictTokenizer.init">
            function <span class="apidocSignatureSpan">segment.DictTokenizer.</span>init
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.DictTokenizer.split">
            function <span class="apidocSignatureSpan">segment.DictTokenizer.</span>split
            <span class="apidocSignatureSpan">(words)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.DictTokenizer.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.EmailOptimizer">module segment.EmailOptimizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.EmailOptimizer.doOptimize">
            function <span class="apidocSignatureSpan">segment.EmailOptimizer.</span>doOptimize
            <span class="apidocSignatureSpan">(words)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.EmailOptimizer.init">
            function <span class="apidocSignatureSpan">segment.EmailOptimizer.</span>init
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.EmailOptimizer.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.ForeignTokenizer">module segment.ForeignTokenizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.ForeignTokenizer.init">
            function <span class="apidocSignatureSpan">segment.ForeignTokenizer.</span>init
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.ForeignTokenizer.split">
            function <span class="apidocSignatureSpan">segment.ForeignTokenizer.</span>split
            <span class="apidocSignatureSpan">(words)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.ForeignTokenizer.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.Optimizer">module segment.Optimizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Optimizer.Optimizer">
            function <span class="apidocSignatureSpan">segment.</span>Optimizer
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.Optimizer.prototype">module segment.Optimizer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Optimizer.prototype.doOptimize">
            function <span class="apidocSignatureSpan">segment.Optimizer.prototype.</span>doOptimize
            <span class="apidocSignatureSpan">(words, modules)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.POSTAG">module segment.POSTAG</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.POSTAG.chsName">
            function <span class="apidocSignatureSpan">segment.POSTAG.</span>chsName
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>A_M</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>A_NR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>A_NS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>A_NT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>A_NX</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>A_NZ</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>A_Q</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_A</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_B</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_C</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_D</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_E</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_F</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_I</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_K</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_L</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_MQ</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_N</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_O</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_P</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_R</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_S</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_T</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_U</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_V</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_W</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_X</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_Y</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_Z</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>D_ZH</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>UNK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>URL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>a_m</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>a_nr</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>a_ns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>a_nt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>a_nx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>a_nz</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>a_q</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_a</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_b</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_c</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_d</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_e</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_f</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_i</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_k</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_l</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_mq</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_n</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_o</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_p</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_r</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_s</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_t</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_u</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_v</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_w</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_x</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_y</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_z</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>d_zh</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>unk</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">segment.POSTAG.</span>url</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.POSTAG.</span>CHSNAME</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.PunctuationTokenizer">module segment.PunctuationTokenizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.PunctuationTokenizer.init">
            function <span class="apidocSignatureSpan">segment.PunctuationTokenizer.</span>init
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.PunctuationTokenizer.split">
            function <span class="apidocSignatureSpan">segment.PunctuationTokenizer.</span>split
            <span class="apidocSignatureSpan">(words)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.PunctuationTokenizer.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.Segment">module segment.Segment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment.Segment">
            function <span class="apidocSignatureSpan">segment.</span>Segment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">segment.Segment.</span>POSTAG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.Segment.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.Segment.prototype">module segment.Segment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment.prototype._resolveDictFilename">
            function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>_resolveDictFilename
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment.prototype.doSegment">
            function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>doSegment
            <span class="apidocSignatureSpan">(text, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment.prototype.getDict">
            function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>getDict
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment.prototype.indexOf">
            function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(words, s, cur)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment.prototype.loadDict">
            function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>loadDict
            <span class="apidocSignatureSpan">(name, type, convert_to_lower)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment.prototype.loadStopwordDict">
            function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>loadStopwordDict
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment.prototype.loadSynonymDict">
            function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>loadSynonymDict
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment.prototype.split">
            function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>split
            <span class="apidocSignatureSpan">(words, s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment.prototype.toString">
            function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>toString
            <span class="apidocSignatureSpan">(words)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment.prototype.use">
            function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>use
            <span class="apidocSignatureSpan">(module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Segment.prototype.useDefault">
            function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>useDefault
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.SingleTokenizer">module segment.SingleTokenizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.SingleTokenizer.init">
            function <span class="apidocSignatureSpan">segment.SingleTokenizer.</span>init
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.SingleTokenizer.split">
            function <span class="apidocSignatureSpan">segment.SingleTokenizer.</span>split
            <span class="apidocSignatureSpan">(words)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.SingleTokenizer.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.Tokenizer">module segment.Tokenizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Tokenizer.Tokenizer">
            function <span class="apidocSignatureSpan">segment.</span>Tokenizer
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.Tokenizer.prototype">module segment.Tokenizer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.Tokenizer.prototype.split">
            function <span class="apidocSignatureSpan">segment.Tokenizer.prototype.</span>split
            <span class="apidocSignatureSpan">(text, modules)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.URLTokenizer">module segment.URLTokenizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.URLTokenizer.init">
            function <span class="apidocSignatureSpan">segment.URLTokenizer.</span>init
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.URLTokenizer.split">
            function <span class="apidocSignatureSpan">segment.URLTokenizer.</span>split
            <span class="apidocSignatureSpan">(words)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.URLTokenizer.</span>type</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.segment.WildcardTokenizer">module segment.WildcardTokenizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.WildcardTokenizer.init">
            function <span class="apidocSignatureSpan">segment.WildcardTokenizer.</span>init
            <span class="apidocSignatureSpan">(segment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.segment.WildcardTokenizer.split">
            function <span class="apidocSignatureSpan">segment.WildcardTokenizer.</span>split
            <span class="apidocSignatureSpan">(words)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">segment.WildcardTokenizer.</span>type</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment" id="apidoc.module.segment">module segment</a></h1>


    <h2>
        <a href="#apidoc.element.segment.segment" id="apidoc.element.segment.segment">
        function <span class="apidocSignatureSpan"></span>segment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">segment = function () {
  this.POSTAG = POSTAG; // 词性
  this.DICT = {};       // 词典表
  this.modules = {
    tokenizer:  [],     // 分词模块
    optimizer:  []      // 优化模块
  };
  this.tokenizer = new Tokenizer(this);
  this.optimizer = new Optimizer(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Optimizer" id="apidoc.element.segment.Optimizer">
        function <span class="apidocSignatureSpan">segment.</span>Optimizer
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Optimizer = function (segment) {
  this.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Segment" id="apidoc.element.segment.Segment">
        function <span class="apidocSignatureSpan">segment.</span>Segment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Segment = function () {
  this.POSTAG = POSTAG; // 词性
  this.DICT = {};       // 词典表
  this.modules = {
    tokenizer:  [],     // 分词模块
    optimizer:  []      // 优化模块
  };
  this.tokenizer = new Tokenizer(this);
  this.optimizer = new Optimizer(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var r = repl.start(&#x27;&#x3e; &#x27;);
var c = r.context;

c._load = function () {
c.Segment = require(&#x27;./&#x27;);
var segment = new c.<span class="apidocCodeKeywordSpan">Segment</span>();
segment.useDefault();
c.segment = segment;
c.s = function () {
  return c.segment.doSegment.apply(c.segment, arguments);
};
c.ss = function () {
  var list = c.s.apply(null, arguments);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Tokenizer" id="apidoc.element.segment.Tokenizer">
        function <span class="apidocSignatureSpan">segment.</span>Tokenizer
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Tokenizer = function (segment) {
  this.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.ChsNameOptimizer" id="apidoc.module.segment.ChsNameOptimizer">module segment.ChsNameOptimizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.ChsNameOptimizer.doOptimize" id="apidoc.element.segment.ChsNameOptimizer.doOptimize">
        function <span class="apidocSignatureSpan">segment.ChsNameOptimizer.</span>doOptimize
        <span class="apidocSignatureSpan">(words)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doOptimize = function (words) {
  //debug(words);
  var POSTAG = exports.segment.POSTAG;
  var i = 0;

<span class="apidocCodeCommentSpan">  /* 第一遍扫描 */
</span>  while (i &#x3c; words.length) {
    var word = words[i];
    var nextword = words[i + 1];
    if (nextword) {
      //debug(nextword);
      // 如果为  &#x22;小|老&#x22; + 姓
      if (nextword &#x26;&#x26; (word.w == &#x27;小&#x27; || word.w == &#x27;老&#x27;) &#x26;&#x26;
      (nextword.w in FAMILY_NAME_1 || nextword.w in FAMILY_NAME_2)) {
        words.splice(i, 2, {
          w:  word.w + nextword.w,
          p:  POSTAG.A_NR
        });
        i++;
        continue;
      }

      // 如果是 姓 + 名（2字以内）
      if ((word.w in FAMILY_NAME_1 || word.w in FAMILY_NAME_2) &#x26;&#x26;
      ((nextword.p &#x26; POSTAG.A_NR) &#x3e; 0 &#x26;&#x26; nextword.w.length &#x3c;= 2)) {
        words.splice(i, 2, {
          w:  word.w + nextword.w,
          p:  POSTAG.A_NR
        });
        i++;
        continue;
      }

      // 如果相邻两个均为单字且至少有一个字是未识别的，则尝试判断其是否为人名
      if (!word.p || !nextword.p) {
        if ((word.w in SINGLE_NAME &#x26;&#x26; word.w == nextword.w) ||
        (word.w in DOUBLE_NAME_1 &#x26;&#x26; nextword.w in DOUBLE_NAME_2)) {
          words.splice(i, 2, {
            w:  word.w + nextword.w,
            p:  POSTAG.A_NR
          });
          // 如果上一个单词可能是一个姓，则合并
          var preword = words[i - 1];
          if (preword &#x26;&#x26;
          (preword.w in FAMILY_NAME_1 || preword.w in FAMILY_NAME_2)) {
            words.splice(i - 1, 2, {
              w:  preword.w + word.w + nextword.w,
              p:  POSTAG.A_NR
            });
          } else {
            i++;
          }
          continue;
        }
      }

      // 如果为 无歧义的姓 + 名（2字以内） 且其中一个未未识别词
      if ((word.w in FAMILY_NAME_1 || word.w in FAMILY_NAME_2) &#x26;&#x26;
          (!word.p || !nextword.p)) {
        //debug(word, nextword);
        words.splice(i, 2, {
          w:  word.w + nextword.w,
          p:  POSTAG.A_NR
        });
      }
    }

    // 移到下一个单词
    i++;
  }

  /* 第二遍扫描 */
  i = 0;
  while (i &#x3c; words.length) {
    var word = words[i];
    var nextword = words[i + 1];
    if (nextword) {
      // 如果为 姓 + 单字名
      if ((word.w in FAMILY_NAME_1 || word.w in FAMILY_NAME_2) &#x26;&#x26;
      nextword.w in SINGLE_NAME) {
        words.splice(i, 2, {
          w:  word.w + nextword.w,
          p:  POSTAG.A_NR
        });
        i++;
        continue;
      }
    }

    // 移到下一个单词
    i++;
  }

  return words;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {array} words 单词数组
 * @param {array} modules 分词模块数组
 * @return {array}
 */
Optimizer.prototype.doOptimize = function (words, modules) {
  // 按顺序分别调用各个module来进行分词 ： 各个module仅对没有识别类型的单词进行分词
  modules.forEach(function (module) {
    words = module.<span class="apidocCodeKeywordSpan">doOptimize</span>(words);
  });
  return words;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.ChsNameOptimizer.init" id="apidoc.element.segment.ChsNameOptimizer.init">
        function <span class="apidocSignatureSpan">segment.ChsNameOptimizer.</span>init
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (segment) {
  exports.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!fs.existsSync(filename)) {
        throw Error(&#x27;Cannot find module &#x22;&#x27; + module + &#x27;&#x22;.&#x27;);
      } else {
        module = require(filename);
      }
    }
    // 初始化并注册模块
    module.<span class="apidocCodeKeywordSpan">init</span>(this);
    this.modules[module.type].push(module);
  }

  return this;
};

Segment.prototype._resolveDictFilename = function (name) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.ChsNameTokenizer" id="apidoc.module.segment.ChsNameTokenizer">module segment.ChsNameTokenizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.ChsNameTokenizer.init" id="apidoc.element.segment.ChsNameTokenizer.init">
        function <span class="apidocSignatureSpan">segment.ChsNameTokenizer.</span>init
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (segment) {
  exports.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!fs.existsSync(filename)) {
        throw Error(&#x27;Cannot find module &#x22;&#x27; + module + &#x27;&#x22;.&#x27;);
      } else {
        module = require(filename);
      }
    }
    // 初始化并注册模块
    module.<span class="apidocCodeKeywordSpan">init</span>(this);
    this.modules[module.type].push(module);
  }

  return this;
};

Segment.prototype._resolveDictFilename = function (name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.ChsNameTokenizer.split" id="apidoc.element.segment.ChsNameTokenizer.split">
        function <span class="apidocSignatureSpan">segment.ChsNameTokenizer.</span>split
        <span class="apidocSignatureSpan">(words)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (words) {
  var POSTAG = exports.segment.POSTAG;
  var ret = [];
  for (var i = 0, word; word = words[i]; i++) {
    if (word.p &#x3e; 0) {
      ret.push(word);
      continue;
    }
    // 仅对未识别的词进行匹配
    var nameinfo = matchName(word.w);
    if (nameinfo.length &#x3c; 1) {
      ret.push(word);
      continue;
    }
    // 分离出人名
    var lastc = 0;
    for (var ui = 0, url; url = nameinfo[ui]; ui++) {
      if (url.c &#x3e; lastc) {
        ret.push({w: word.w.substr(lastc, url.c - lastc)});
      }
      ret.push({w: url.w, p: POSTAG.A_NR});
      lastc = url.c + url.w.length;
    }
    var lastn = nameinfo[nameinfo.length - 1];
    if (lastn.c + lastn.w.length &#x3c; word.w.length) {
      ret.push({w: word.w.substr(lastn.c + lastn.w.length)});
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ret[i].ps = POSTAG.chsName(ret[i].p);
}
console.log(ret);
console.log(line);
console.log(&#x27;spent &#x27; + ((e - s) / NUM) + &#x27;ms&#x27;);
return;
console.log(segment.toString(ret));
var split = segment.<span class="apidocCodeKeywordSpan">split</span>(ret, &#x27;是&#x27;);
for (var i in split)
  console.log(segment.toString(split[i]));
console.log(segment.indexOf(ret, &#x27;的&#x27;, 3));
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.DatetimeOptimizer" id="apidoc.module.segment.DatetimeOptimizer">module segment.DatetimeOptimizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.DatetimeOptimizer.doOptimize" id="apidoc.element.segment.DatetimeOptimizer.doOptimize">
        function <span class="apidocSignatureSpan">segment.DatetimeOptimizer.</span>doOptimize
        <span class="apidocSignatureSpan">(words, is_not_first)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doOptimize = function (words, is_not_first) {
  if (typeof is_not_first == &#x27;undefined&#x27;) {
    is_not_first = false;
  }
  // 合并相邻的能组成一个单词的两个词
  var TABLE = exports.segment.getDict(&#x27;TABLE&#x27;);
  var POSTAG = exports.segment.POSTAG;

  var i = 0;
  var ie = words.length - 1;
  while (i &#x3c; ie) {
    var w1 = words[i];
    var w2 = words[i + 1];
    //debug(w1.w + &#x27;, &#x27; + w2.w);

    if ((w1.p &#x26; POSTAG.A_M) &#x3e; 0) {
      // =========================================
      // 日期时间组合   数字 + 日期单位，如 “2005年&#x22;
      if (w2.w in DATETIME) {
        var nw = w1.w + w2.w;
        var len = 2;
        // 继续搜索后面连续的日期时间描述，必须符合  数字 + 日期单位
        while (true) {
          var w1 = words[i + len];
          var w2 = words[i + len + 1];
          if (w1 &#x26;&#x26; w2 &#x26;&#x26; (w1.p &#x26; POSTAG.A_M) &#x3e; 0 &#x26;&#x26; w2.w in DATETIME) {
            len += 2;
            nw += w1.w + w2.w;
          } else {
            break;
          }
        }
        words.splice(i, len, {
          w:  nw,
          p:  POSTAG.D_T
        });
        ie -= len - 1;
        continue;
      }
      // =========================================
    }

    // 移到下一个词
    i++;
  }

  return words;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {array} words 单词数组
 * @param {array} modules 分词模块数组
 * @return {array}
 */
Optimizer.prototype.doOptimize = function (words, modules) {
  // 按顺序分别调用各个module来进行分词 ： 各个module仅对没有识别类型的单词进行分词
  modules.forEach(function (module) {
    words = module.<span class="apidocCodeKeywordSpan">doOptimize</span>(words);
  });
  return words;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.DatetimeOptimizer.init" id="apidoc.element.segment.DatetimeOptimizer.init">
        function <span class="apidocSignatureSpan">segment.DatetimeOptimizer.</span>init
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (segment) {
  exports.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!fs.existsSync(filename)) {
        throw Error(&#x27;Cannot find module &#x22;&#x27; + module + &#x27;&#x22;.&#x27;);
      } else {
        module = require(filename);
      }
    }
    // 初始化并注册模块
    module.<span class="apidocCodeKeywordSpan">init</span>(this);
    this.modules[module.type].push(module);
  }

  return this;
};

Segment.prototype._resolveDictFilename = function (name) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.DictOptimizer" id="apidoc.module.segment.DictOptimizer">module segment.DictOptimizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.DictOptimizer.doOptimize" id="apidoc.element.segment.DictOptimizer.doOptimize">
        function <span class="apidocSignatureSpan">segment.DictOptimizer.</span>doOptimize
        <span class="apidocSignatureSpan">(words, is_not_first)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doOptimize = function (words, is_not_first) {
  //debug(words);
  if (typeof is_not_first == &#x27;undefined&#x27;) {
    is_not_first = false;
  }
  // 合并相邻的能组成一个单词的两个词
  var TABLE = exports.segment.getDict(&#x27;TABLE&#x27;);
  var POSTAG = exports.segment.POSTAG;

  var i = 0;
  var ie = words.length - 1;
  while (i &#x3c; ie) {
    var w1 = words[i];
    var w2 = words[i + 1];
    //debug(w1.w + &#x27;, &#x27; + w2.w);

    // ==========================================
    // 能组成一个新词的(词性必须相同)
    var nw = w1.w + w2.w;
    if (w1.p == w2.p &#x26;&#x26; nw in TABLE) {
      words.splice(i, 2, {
        w:  nw,
        p:  TABLE[nw].p
      });
      ie--;
      continue;
    }

    // 形容词 + 助词 = 形容词，如： 不同 + 的 = 不同的
    if ((w1.p &#x26; POSTAG.D_A) &#x3e; 0 &#x26;&#x26; (w2.p &#x26; POSTAG.D_U)) {
      words.splice(i, 2, {
        w:  nw,
        p:  POSTAG.D_A
      });
      ie--;
      continue;
    }

    // ============================================
    // 数词组合
    if ((w1.p &#x26; POSTAG.A_M) &#x3e; 0) {
      //debug(w2.w + &#x27; &#x27; + (w2.p &#x26; POSTAG.A_M));
      // 百分比数字 如 10%，或者下一个词也是数词，则合并
      if ((w2.p &#x26; POSTAG.A_M) &#x3e; 0 || w2.w == &#x27;%&#x27;) {
        words.splice(i, 2, {
          w:  w1.w + w2.w,
          p:  POSTAG.A_M
        });
        ie--;
        continue;
      }
      // 数词 + 量词，合并。如： 100个
      if ((w2.p &#x26; POSTAG.A_Q) &#x3e; 0) {
        words.splice(i, 2, {
          w:  w1.w + w2.w,
          p:  POSTAG.D_MQ // 数量词
        });
        ie--;
        continue;
      }
      // 带小数点的数字 ，如 “3 . 14”，或者 “十五点三”
      // 数词 + &#x22;分之&#x22; + 数词，如“五十分之一”
      var w3 = words[i + 2];
      if (w3 &#x26;&#x26; (w3.p &#x26; POSTAG.A_M) &#x3e; 0 &#x26;&#x26;
         (w2.w == &#x27;.&#x27; || w2.w == &#x27;点&#x27; || w2.w == &#x27;分之&#x27;)) {
        words.splice(i, 3, {
          w:  w1.w + w2.w + w3.w,
          p:  POSTAG.A_M
        });
        ie -= 2;
        continue;
      }
    }

    // 修正 “十五点五八”问题
    if ((w1.p &#x26; POSTAG.D_MQ) &#x3e; 0 &#x26;&#x26; w1.w.substr(-1) === &#x27;点&#x27; &#x26;&#x26; w2.p &#x26; POSTAG.A_M) {
      //debug(w1, w2);
      var i2 = 2;
      var w4w = &#x27;&#x27;;
      for (var j = i + i2; j &#x3c; ie; j++) {
        var w3 = words[j];
        if ((w3.p &#x26; POSTAG.A_M) &#x3e; 0) {
          w4w += w3.w;
          i2++;
        } else {
          break;
        }
      }
      words.splice(i, i2, {
        w:  w1.w + w2.w + w4w,
        p:  POSTAG.D_MQ // 数量词
      });
      ie -= i2 - 1;
      continue;
    }

    // 移到下一个词
    i++;
  }

  // 针对组合数字后无法识别新组合的数字问题，需要重新扫描一次
  return is_not_first === true ? words : exports.doOptimize(words, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {array} words 单词数组
 * @param {array} modules 分词模块数组
 * @return {array}
 */
Optimizer.prototype.doOptimize = function (words, modules) {
  // 按顺序分别调用各个module来进行分词 ： 各个module仅对没有识别类型的单词进行分词
  modules.forEach(function (module) {
    words = module.<span class="apidocCodeKeywordSpan">doOptimize</span>(words);
  });
  return words;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.DictOptimizer.init" id="apidoc.element.segment.DictOptimizer.init">
        function <span class="apidocSignatureSpan">segment.DictOptimizer.</span>init
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (segment) {
  exports.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!fs.existsSync(filename)) {
        throw Error(&#x27;Cannot find module &#x22;&#x27; + module + &#x27;&#x22;.&#x27;);
      } else {
        module = require(filename);
      }
    }
    // 初始化并注册模块
    module.<span class="apidocCodeKeywordSpan">init</span>(this);
    this.modules[module.type].push(module);
  }

  return this;
};

Segment.prototype._resolveDictFilename = function (name) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.DictTokenizer" id="apidoc.module.segment.DictTokenizer">module segment.DictTokenizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.DictTokenizer.init" id="apidoc.element.segment.DictTokenizer.init">
        function <span class="apidocSignatureSpan">segment.DictTokenizer.</span>init
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (segment) {
  exports.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!fs.existsSync(filename)) {
        throw Error(&#x27;Cannot find module &#x22;&#x27; + module + &#x27;&#x22;.&#x27;);
      } else {
        module = require(filename);
      }
    }
    // 初始化并注册模块
    module.<span class="apidocCodeKeywordSpan">init</span>(this);
    this.modules[module.type].push(module);
  }

  return this;
};

Segment.prototype._resolveDictFilename = function (name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.DictTokenizer.split" id="apidoc.element.segment.DictTokenizer.split">
        function <span class="apidocSignatureSpan">segment.DictTokenizer.</span>split
        <span class="apidocSignatureSpan">(words)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (words) {
  // debug(words);
  var POSTAG = exports.segment.POSTAG;
  var TABLE = exports.segment.getDict(&#x27;TABLE&#x27;);
  var ret = [];
  for (var i = 0, word; word = words[i]; i++) {
    if (word.p &#x3e; 0) {
      ret.push(word);
      continue;
    }
    // 仅对未识别的词进行匹配
    var wordinfo = matchWord(word.w, 0, words[i - 1]);
    if (wordinfo.length &#x3c; 1) {
      ret.push(word);
      continue;
    }
    // 分离出已识别的单词
    var lastc = 0;
    for (var ui = 0, bw; bw = wordinfo[ui]; ui++) {
      if (bw.c &#x3e; lastc) {
        ret.push({w: word.w.substr(lastc, bw.c - lastc)});
      }
      ret.push({w: bw.w, p: TABLE[bw.w].p});
      lastc = bw.c + bw.w.length;
    }
    var lastword = wordinfo[wordinfo.length - 1];
    if (lastword.c + lastword.w.length &#x3c; word.w.length) {
      ret.push({w: word.w.substr(lastword.c + lastword.w.length)});
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ret[i].ps = POSTAG.chsName(ret[i].p);
}
console.log(ret);
console.log(line);
console.log(&#x27;spent &#x27; + ((e - s) / NUM) + &#x27;ms&#x27;);
return;
console.log(segment.toString(ret));
var split = segment.<span class="apidocCodeKeywordSpan">split</span>(ret, &#x27;是&#x27;);
for (var i in split)
  console.log(segment.toString(split[i]));
console.log(segment.indexOf(ret, &#x27;的&#x27;, 3));
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.EmailOptimizer" id="apidoc.module.segment.EmailOptimizer">module segment.EmailOptimizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.EmailOptimizer.doOptimize" id="apidoc.element.segment.EmailOptimizer.doOptimize">
        function <span class="apidocSignatureSpan">segment.EmailOptimizer.</span>doOptimize
        <span class="apidocSignatureSpan">(words)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doOptimize = function (words) {
  var POSTAG = exports.segment.POSTAG;
  //debug(words);

  var i = 0;
  var ie = words.length - 1;
  var addr_start = false;
  var has_at = false;
  while (i &#x3c; ie) {
    var word = words[i];
    var is_ascii = ((word.p == POSTAG.A_NX) ||
            (word.p == POSTAG.A_M &#x26;&#x26; word.w.charCodeAt(0) &#x3c; 128))
            ? true : false;

    // 如果是外文字符或者数字，符合电子邮件地址开头的条件
    if (addr_start === false &#x26;&#x26; is_ascii) {
      addr_start = i;
      i++;
      continue;
    } else {
      // 如果遇到@符号，符合第二个条件
      if (has_at === false &#x26;&#x26; word.w == &#x27;@&#x27;) {
        has_at = true;
        i++;
        continue;
      }
      // 如果已经遇到过@符号，且出现了其他字符，则截取邮箱地址
      if (has_at !== false &#x26;&#x26; words[i - 1].w != &#x27;@&#x27; &#x26;&#x26; is_ascii === false &#x26;&#x26; !(word.w in EMAILCHAR)) {
        var mailws = words.slice(addr_start, i);
        //debug(toEmailAddress(mailws));
        words.splice(addr_start, mailws.length, {
          w:  toEmailAddress(mailws),
          p:  POSTAG.URL
        });
        i = addr_start + 1;
        ie -= mailws.length - 1;
        addr_start = false;
        has_at = false;
        continue;
      }
      // 如果已经开头
      if (addr_start !== false &#x26;&#x26; (is_ascii || word.w in EMAILCHAR)) {
        i++;
        continue;
      }
    }

    // 移到下一个词
    addr_start = false;
    has_at = false;
    i++;
  }

  // 检查剩余部分
  if (addr_start &#x26;&#x26; has_at &#x26;&#x26; words[ie]) {
    var word = words[ie];
    var is_ascii = ((word.p == POSTAG.A_NX) ||
            (word.p == POSTAG.A_M &#x26;&#x26; word.w in EMAILCHAR))
            ? true : false;
    if (is_ascii) {
      var mailws = words.slice(addr_start, words.length);
      //debug(toEmailAddress(mailws));
      words.splice(addr_start, mailws.length, {
        w:  toEmailAddress(mailws),
        p:  POSTAG.URL
      });
    }
  }

  return words;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {array} words 单词数组
 * @param {array} modules 分词模块数组
 * @return {array}
 */
Optimizer.prototype.doOptimize = function (words, modules) {
  // 按顺序分别调用各个module来进行分词 ： 各个module仅对没有识别类型的单词进行分词
  modules.forEach(function (module) {
    words = module.<span class="apidocCodeKeywordSpan">doOptimize</span>(words);
  });
  return words;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.EmailOptimizer.init" id="apidoc.element.segment.EmailOptimizer.init">
        function <span class="apidocSignatureSpan">segment.EmailOptimizer.</span>init
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (segment) {
  exports.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!fs.existsSync(filename)) {
        throw Error(&#x27;Cannot find module &#x22;&#x27; + module + &#x27;&#x22;.&#x27;);
      } else {
        module = require(filename);
      }
    }
    // 初始化并注册模块
    module.<span class="apidocCodeKeywordSpan">init</span>(this);
    this.modules[module.type].push(module);
  }

  return this;
};

Segment.prototype._resolveDictFilename = function (name) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.ForeignTokenizer" id="apidoc.module.segment.ForeignTokenizer">module segment.ForeignTokenizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.ForeignTokenizer.init" id="apidoc.element.segment.ForeignTokenizer.init">
        function <span class="apidocSignatureSpan">segment.ForeignTokenizer.</span>init
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (segment) {
  exports.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!fs.existsSync(filename)) {
        throw Error(&#x27;Cannot find module &#x22;&#x27; + module + &#x27;&#x22;.&#x27;);
      } else {
        module = require(filename);
      }
    }
    // 初始化并注册模块
    module.<span class="apidocCodeKeywordSpan">init</span>(this);
    this.modules[module.type].push(module);
  }

  return this;
};

Segment.prototype._resolveDictFilename = function (name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.ForeignTokenizer.split" id="apidoc.element.segment.ForeignTokenizer.split">
        function <span class="apidocSignatureSpan">segment.ForeignTokenizer.</span>split
        <span class="apidocSignatureSpan">(words)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (words) {
  var POSTAG = exports.segment.POSTAG;
  var ret = [];
  for (var i = 0, word; word = words[i]; i++) {
    if (word.p) {
      ret.push(word);
    } else {
      // 仅对未识别的词进行匹配
      ret = ret.concat(splitForeign(word.w));
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ret[i].ps = POSTAG.chsName(ret[i].p);
}
console.log(ret);
console.log(line);
console.log(&#x27;spent &#x27; + ((e - s) / NUM) + &#x27;ms&#x27;);
return;
console.log(segment.toString(ret));
var split = segment.<span class="apidocCodeKeywordSpan">split</span>(ret, &#x27;是&#x27;);
for (var i in split)
  console.log(segment.toString(split[i]));
console.log(segment.indexOf(ret, &#x27;的&#x27;, 3));
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.Optimizer" id="apidoc.module.segment.Optimizer">module segment.Optimizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.Optimizer.Optimizer" id="apidoc.element.segment.Optimizer.Optimizer">
        function <span class="apidocSignatureSpan">segment.</span>Optimizer
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Optimizer = function (segment) {
  this.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.Optimizer.prototype" id="apidoc.module.segment.Optimizer.prototype">module segment.Optimizer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.segment.Optimizer.prototype.doOptimize" id="apidoc.element.segment.Optimizer.prototype.doOptimize">
        function <span class="apidocSignatureSpan">segment.Optimizer.prototype.</span>doOptimize
        <span class="apidocSignatureSpan">(words, modules)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doOptimize = function (words, modules) {
  // 按顺序分别调用各个module来进行分词 ： 各个module仅对没有识别类型的单词进行分词
  modules.forEach(function (module) {
    words = module.doOptimize(words);
  });
  return words;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {array} words 单词数组
 * @param {array} modules 分词模块数组
 * @return {array}
 */
Optimizer.prototype.doOptimize = function (words, modules) {
  // 按顺序分别调用各个module来进行分词 ： 各个module仅对没有识别类型的单词进行分词
  modules.forEach(function (module) {
    words = module.<span class="apidocCodeKeywordSpan">doOptimize</span>(words);
  });
  return words;
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.POSTAG" id="apidoc.module.segment.POSTAG">module segment.POSTAG</a></h1>


    <h2>
        <a href="#apidoc.element.segment.POSTAG.chsName" id="apidoc.element.segment.POSTAG.chsName">
        function <span class="apidocSignatureSpan">segment.POSTAG.</span>chsName
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chsName = function (p) {
  if (isNaN(p)) {
    return CHSNAME[p] || CHSNAME.UNK;
  } else {
    var ret = [];
    for (var i in _POSTAG) {
      if ((p &#x26; _POSTAG[i]) &#x3e; 0) {
        ret.push(CHSNAME[i]);
      }
    }
    if (ret.length &#x3c; 1) {
      return CHSNAME.UNK;
    } else {
      return ret.toString();
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var ret = segment.doSegment(text);

////////////////////////////////////////////////////////////
var e = new Date().getTime();
var line = &#x27;&#x27;;
for (var i in ret) {
  line += ret[i].w + &#x27;/&#x27;;
  ret[i].ps = POSTAG.<span class="apidocCodeKeywordSpan">chsName</span>(ret[i].p);
}
console.log(ret);
console.log(line);
console.log(&#x27;spent &#x27; + ((e - s) / NUM) + &#x27;ms&#x27;);
return;
console.log(segment.toString(ret));
var split = segment.split(ret, &#x27;是&#x27;);
...</pre></li>
    </ul>




































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.PunctuationTokenizer" id="apidoc.module.segment.PunctuationTokenizer">module segment.PunctuationTokenizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.PunctuationTokenizer.init" id="apidoc.element.segment.PunctuationTokenizer.init">
        function <span class="apidocSignatureSpan">segment.PunctuationTokenizer.</span>init
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (segment) {
  exports.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!fs.existsSync(filename)) {
        throw Error(&#x27;Cannot find module &#x22;&#x27; + module + &#x27;&#x22;.&#x27;);
      } else {
        module = require(filename);
      }
    }
    // 初始化并注册模块
    module.<span class="apidocCodeKeywordSpan">init</span>(this);
    this.modules[module.type].push(module);
  }

  return this;
};

Segment.prototype._resolveDictFilename = function (name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.PunctuationTokenizer.split" id="apidoc.element.segment.PunctuationTokenizer.split">
        function <span class="apidocSignatureSpan">segment.PunctuationTokenizer.</span>split
        <span class="apidocSignatureSpan">(words)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (words) {
  var POSTAG = exports.segment.POSTAG;
  var ret = [];
  for (var i = 0, word; word = words[i]; i++) {
    if (word.p &#x3e; 0) {
      ret.push(word);
      continue;
    }
    // 仅对未识别的词进行匹配
    var stopinfo = matchStopword(word.w);
    if (stopinfo.length &#x3c; 1) {
      ret.push(word);
      continue;
    }
    // 分离出标点符号
    var lastc = 0;
    for (var ui = 0, sw; sw = stopinfo[ui]; ui++) {
      if (sw.c &#x3e; lastc) {
        ret.push({w: word.w.substr(lastc, sw.c - lastc)});
      }
      // 忽略空格
      if (sw.w != &#x27; &#x27;) {
        ret.push({w: sw.w, p: POSTAG.D_W});
      }
      lastc = sw.c + sw.w.length;
    }
    var lastsw = stopinfo[stopinfo.length - 1];
    if (lastsw.c + lastsw.w.length &#x3c; word.w.length) {
      ret.push({w: word.w.substr(lastsw.c + lastsw.w.length)});
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ret[i].ps = POSTAG.chsName(ret[i].p);
}
console.log(ret);
console.log(line);
console.log(&#x27;spent &#x27; + ((e - s) / NUM) + &#x27;ms&#x27;);
return;
console.log(segment.toString(ret));
var split = segment.<span class="apidocCodeKeywordSpan">split</span>(ret, &#x27;是&#x27;);
for (var i in split)
  console.log(segment.toString(split[i]));
console.log(segment.indexOf(ret, &#x27;的&#x27;, 3));
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.Segment" id="apidoc.module.segment.Segment">module segment.Segment</a></h1>


    <h2>
        <a href="#apidoc.element.segment.Segment.Segment" id="apidoc.element.segment.Segment.Segment">
        function <span class="apidocSignatureSpan">segment.</span>Segment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Segment = function () {
  this.POSTAG = POSTAG; // 词性
  this.DICT = {};       // 词典表
  this.modules = {
    tokenizer:  [],     // 分词模块
    optimizer:  []      // 优化模块
  };
  this.tokenizer = new Tokenizer(this);
  this.optimizer = new Optimizer(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var r = repl.start(&#x27;&#x3e; &#x27;);
var c = r.context;

c._load = function () {
c.Segment = require(&#x27;./&#x27;);
var segment = new c.<span class="apidocCodeKeywordSpan">Segment</span>();
segment.useDefault();
c.segment = segment;
c.s = function () {
  return c.segment.doSegment.apply(c.segment, arguments);
};
c.ss = function () {
  var list = c.s.apply(null, arguments);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.Segment.prototype" id="apidoc.module.segment.Segment.prototype">module segment.Segment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.segment.Segment.prototype._resolveDictFilename" id="apidoc.element.segment.Segment.prototype._resolveDictFilename">
        function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>_resolveDictFilename
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_resolveDictFilename = function (name) {
  var filename = path.resolve(name);
  if (!fs.existsSync(filename)) {
    var filename = path.resolve(__dirname, &#x27;../dicts&#x27;, name);
    if (!fs.existsSync(filename)) {
      throw Error(&#x27;Cannot find dict file &#x22;&#x27; + filename + &#x27;&#x22;.&#x27;);
    }
  }
  return filename;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {String} name 字典文件名
 * @param {String} type 类型
 * @param {Boolean} convert_to_lower 是否全部转换为小写
 * @return {Segment}
 */
Segment.prototype.loadDict = function (name, type, convert_to_lower) {
var filename = this.<span class="apidocCodeKeywordSpan">_resolveDictFilename</span>(name);
if (!type)  type = &#x27;TABLE&#x27;;     // 默认为TABLE

// 初始化词典
if (!this.DICT[type]) this.DICT[type] = {};
if (!this.DICT[type + &#x27;2&#x27;]) this.DICT[type + &#x27;2&#x27;] = {};
var TABLE = this.DICT[type];        // 词典表  &#x27;词&#x27; =&#x3e; {属性}
var TABLE2 = this.DICT[type + &#x27;2&#x27;]; // 词典表  &#x27;长度&#x27; =&#x3e; &#x27;词&#x27; =&#x3e; 属性
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Segment.prototype.doSegment" id="apidoc.element.segment.Segment.prototype.doSegment">
        function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>doSegment
        <span class="apidocSignatureSpan">(text, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doSegment = function (text, options) {
  var me = this;
  options = options || {};
  var ret = [];

  // 将文本按照换行符分割成多段，并逐一分词
  text.replace(/\r/g, &#x27;\n&#x27;).split(/(\n|\s)+/).forEach(function (section) {
    var section = section.trim();
    if (section.length &#x3c; 1) return;
    // ======================================
    // 分词
    var sret = me.tokenizer.split(section, me.modules.tokenizer);

    // 优化
    sret = me.optimizer.doOptimize(sret, me.modules.optimizer);

    // ======================================
    // 连接分词结果
    if (sret.length &#x3e; 0) ret = ret.concat(sret);
  });

  // 去除标点符号
  if (options.stripPunctuation) {
    ret = ret.filter(function (item) {
      return item.p !== POSTAG.D_W;
    });
  }

  // 转换同义词
  function convertSynonym (list) {
    var count = 0;
    var TABLE = me.getDict(&#x27;SYNONYM&#x27;);
    list = list.map(function (item) {
      if (item.w in TABLE) {
        count++;
        return {w: TABLE[item.w], p: item.p};
      } else {
        return item;
      }
    });
    return {count: count, list: list};
  }
  if (options.convertSynonym) {
    do {
      var result = convertSynonym(ret);
      ret = result.list;
    } while (result.count &#x3e; 0);
  }

  // 去除停止符
  if (options.stripStopword) {
    var STOPWORD = me.getDict(&#x27;STOPWORD&#x27;);
    ret = ret.filter(function (item) {
      return !(item.w in STOPWORD);
    });
  }

  // 仅返回单词内容
  if (options.simple) {
    ret = ret.map(function (item) {
      return item.w;
    });
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
使用示例：

var segment = new Segment();
// 使用默认的识别模块及字典
segment.useDefault();
// 开始分词
console.log(segment.<span class="apidocCodeKeywordSpan">doSegment</span>(&#x27;这是一个基于Node.js的中文分词模块。&#x27;));

*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Segment.prototype.getDict" id="apidoc.element.segment.Segment.prototype.getDict">
        function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>getDict
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDict = function (type) {
  return this.DICT[type];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return item.p !== POSTAG.D_W;
  });
}

// 转换同义词
function convertSynonym (list) {
  var count = 0;
  var TABLE = me.<span class="apidocCodeKeywordSpan">getDict</span>(&#x27;SYNONYM&#x27;);
  list = list.map(function (item) {
    if (item.w in TABLE) {
      count++;
      return {w: TABLE[item.w], p: item.p};
    } else {
      return item;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Segment.prototype.indexOf" id="apidoc.element.segment.Segment.prototype.indexOf">
        function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(words, s, cur)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (words, s, cur) {
  cur = isNaN(cur) ? 0 : cur;
  var f = typeof s === &#x27;string&#x27; ? &#x27;w&#x27; : &#x27;p&#x27;;

  while (cur &#x3c; words.length) {
    if (words[cur][f] == s) return cur;
    cur++;
  }

  return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };
};

c.reload = function () {
  var t = Date.now();
  var dir = path.resolve(__dirname) + path.sep;
  for (var i in require.cache) {
    if (i.<span class="apidocCodeKeywordSpan">indexOf</span>(dir) === 0) {
      delete require.cache[i];
      // console.log(&#x27;delete %s&#x27;, i);
    }
  }
  c._load();
  console.log(&#x27;OK. (spent %sms)&#x27;, Date.now() - t);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Segment.prototype.loadDict" id="apidoc.element.segment.Segment.prototype.loadDict">
        function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>loadDict
        <span class="apidocSignatureSpan">(name, type, convert_to_lower)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadDict = function (name, type, convert_to_lower) {
  var filename = this._resolveDictFilename(name);
  if (!type)  type = &#x27;TABLE&#x27;;     // 默认为TABLE

  // 初始化词典
  if (!this.DICT[type]) this.DICT[type] = {};
  if (!this.DICT[type + &#x27;2&#x27;]) this.DICT[type + &#x27;2&#x27;] = {};
  var TABLE = this.DICT[type];        // 词典表  &#x27;词&#x27; =&#x3e; {属性}
  var TABLE2 = this.DICT[type + &#x27;2&#x27;]; // 词典表  &#x27;长度&#x27; =&#x3e; &#x27;词&#x27; =&#x3e; 属性
  // 导入数据
  var POSTAG = this.POSTAG;
  var data = fs.readFileSync(filename, &#x27;utf8&#x27;);
  if (convert_to_lower) data = data.toLowerCase();

  data.split(/\r?\n/).forEach(function (line) {
    var blocks = line.split(&#x27;|&#x27;);
    if (blocks.length &#x3e; 2) {
      var w = blocks[0].trim();
      var p = Number(blocks[1]);
      var f = Number(blocks[2]);

      // 一定要检查单词是否为空，如果为空会导致Bug
      if (w.length &#x3e; 0) {
        TABLE[w] = {f: f, p: p};
        if (!TABLE2[w.length]) TABLE2[w.length] = {};
        TABLE2[w.length][w] = TABLE[w];
      }
    }
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
// 载入模块
var Segment = require(&#x27;segment&#x27;);
// 创建实例
var segment = new Segment();
// 配置，可根据实际情况增删，详见segment.useDefault()方法
segment.use(&#x27;URLTokenizer&#x27;);  // 载入识别模块，详见lib/module目录，或者是自定义模块的绝对路径
segment.<span class="apidocCodeKeywordSpan">loadDict</span>(&#x27;dict.txt&#x27;); // 载入字典，详见dicts目录，或者是自定义字典文件的绝对路径

// 开始分词
console.log(segment.doSegment(&#x27;这是一个基于Node.js的中文分词模块。&#x27;));
```

一般可通过 `segment.useDefault()` 来载入默认的配置，若要自定义加载，可参考 `useDefault()` 的代码：
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Segment.prototype.loadStopwordDict" id="apidoc.element.segment.Segment.prototype.loadStopwordDict">
        function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>loadStopwordDict
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadStopwordDict = function (name) {
  var filename = this._resolveDictFilename(name);
  var type = &#x27;STOPWORD&#x27;;

  // 初始化词典
  if (!this.DICT[type]) this.DICT[type] = {};
  var TABLE = this.DICT[type];        // 词典表  &#x27;同义词&#x27; =&#x3e; &#x27;标准词&#x27;
  // 导入数据
  var data = fs.readFileSync(filename, &#x27;utf8&#x27;);

  data.split(/\r?\n/).forEach(function (line) {
    line = line.trim();
    if (line) {
      TABLE[line] = true;
    }
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### 去除停止符

载入词典：

```javascript
segment.<span class="apidocCodeKeywordSpan">loadStopwordDict</span>(&#x27;stopword.txt&#x27;);
```

词典格式：

```
之所以
因为
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Segment.prototype.loadSynonymDict" id="apidoc.element.segment.Segment.prototype.loadSynonymDict">
        function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>loadSynonymDict
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadSynonymDict = function (name) {
  var filename = this._resolveDictFilename(name);
  var type = &#x27;SYNONYM&#x27;;

  // 初始化词典
  if (!this.DICT[type]) this.DICT[type] = {};
  var TABLE = this.DICT[type];        // 词典表  &#x27;同义词&#x27; =&#x3e; &#x27;标准词&#x27;
  // 导入数据
  var data = fs.readFileSync(filename, &#x27;utf8&#x27;);

  data.split(/\r?\n/).forEach(function (line) {
    var blocks = line.split(&#x27;,&#x27;);
    if (blocks.length &#x3e; 1) {
      var n1 = blocks[0].trim();
      var n2 = blocks[1].trim();
      TABLE[n1] = n2;
      if (TABLE[n2] === n1) {
        delete TABLE[n2];
      }
    }
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### 转换同义词

载入同义词词典：

```javascript
segment.<span class="apidocCodeKeywordSpan">loadSynonymDict</span>(&#x27;synonym.txt&#x27;);
```

词典格式：

```
什么时候,何时
入眠,入睡
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Segment.prototype.split" id="apidoc.element.segment.Segment.prototype.split">
        function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>split
        <span class="apidocSignatureSpan">(words, s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (words, s) {
  var ret = [];
  var lasti = 0;
  var i = 0;
  var f = typeof s === &#x27;string&#x27; ? &#x27;w&#x27; : &#x27;p&#x27;;

  while (i &#x3c; words.length) {
    if (words[i][f] == s) {
      if (lasti &#x3c; i) ret.push(words.slice(lasti, i));
      ret.push(words.slice(i, i + 1));
      i++;
      lasti = i;
    } else {
      i++;
    }
  }
  if (lasti &#x3c; words.length - 1) {
    ret.push(words.slice(lasti, words.length));
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ret[i].ps = POSTAG.chsName(ret[i].p);
}
console.log(ret);
console.log(line);
console.log(&#x27;spent &#x27; + ((e - s) / NUM) + &#x27;ms&#x27;);
return;
console.log(segment.toString(ret));
var split = segment.<span class="apidocCodeKeywordSpan">split</span>(ret, &#x27;是&#x27;);
for (var i in split)
  console.log(segment.toString(split[i]));
console.log(segment.indexOf(ret, &#x27;的&#x27;, 3));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Segment.prototype.toString" id="apidoc.element.segment.Segment.prototype.toString">
        function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>toString
        <span class="apidocSignatureSpan">(words)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (words) {
  return words.map(function (item) {
    return item.w;
  }).join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  line += ret[i].w + &#x27;/&#x27;;
  ret[i].ps = POSTAG.chsName(ret[i].p);
}
console.log(ret);
console.log(line);
console.log(&#x27;spent &#x27; + ((e - s) / NUM) + &#x27;ms&#x27;);
return;
console.log(segment.<span class="apidocCodeKeywordSpan">toString</span>(ret));
var split = segment.split(ret, &#x27;是&#x27;);
for (var i in split)
  console.log(segment.toString(split[i]));
console.log(segment.indexOf(ret, &#x27;的&#x27;, 3));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Segment.prototype.use" id="apidoc.element.segment.Segment.prototype.use">
        function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>use
        <span class="apidocSignatureSpan">(module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (module) {
  var me = this;

  if (Array.isArray(module)) {
    module.forEach(function (module) {
      me.use(module[i]);
    });

  } else {
    if (typeof module == &#x27;string&#x27;) {
      var filename = path.resolve(__dirname, &#x27;module&#x27;, module + &#x27;.js&#x27;);
      if (!fs.existsSync(filename)) {
        throw Error(&#x27;Cannot find module &#x22;&#x27; + module + &#x27;&#x22;.&#x27;);
      } else {
        module = require(filename);
      }
    }
    // 初始化并注册模块
    module.init(this);
    this.modules[module.type].push(module);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
// 载入模块
var Segment = require(&#x27;segment&#x27;);
// 创建实例
var segment = new Segment();
// 配置，可根据实际情况增删，详见segment.useDefault()方法
segment.<span class="apidocCodeKeywordSpan">use</span>(&#x27;URLTokenizer&#x27;);  // 载入识别模块，详见lib/module目录，或者是自定义模块的绝对路径
segment.loadDict(&#x27;dict.txt&#x27;); // 载入字典，详见dicts目录，或者是自定义字典文件的绝对路径

// 开始分词
console.log(segment.doSegment(&#x27;这是一个基于Node.js的中文分词模块。&#x27;));
```

一般可通过 `segment.useDefault()` 来载入默认的配置，若要自定义加载，可参考 `useDefault()` 的代码：
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.Segment.prototype.useDefault" id="apidoc.element.segment.Segment.prototype.useDefault">
        function <span class="apidocSignatureSpan">segment.Segment.prototype.</span>useDefault
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">useDefault = function () {
  this
    // 识别模块
    // 强制分割类单词识别
    .use(&#x27;URLTokenizer&#x27;)            // URL识别
    .use(&#x27;WildcardTokenizer&#x27;)       // 通配符，必须在标点符号识别之前
    .use(&#x27;PunctuationTokenizer&#x27;)    // 标点符号识别
    .use(&#x27;ForeignTokenizer&#x27;)        // 外文字符、数字识别，必须在标点符号识别之后
    // 中文单词识别
    .use(&#x27;DictTokenizer&#x27;)           // 词典识别
    .use(&#x27;ChsNameTokenizer&#x27;)        // 人名识别，建议在词典识别之后

    // 优化模块
    .use(&#x27;EmailOptimizer&#x27;)          // 邮箱地址识别
    .use(&#x27;ChsNameOptimizer&#x27;)        // 人名识别优化
    .use(&#x27;DictOptimizer&#x27;)           // 词典识别优化
    .use(&#x27;DatetimeOptimizer&#x27;)       // 日期时间识别优化

    // 字典文件
    .loadDict(&#x27;dict.txt&#x27;)           // 盘古词典
    .loadDict(&#x27;dict2.txt&#x27;)          // 扩展词典（用于调整原盘古词典）
    .loadDict(&#x27;dict3.txt&#x27;)          // 扩展词典（用于调整原盘古词典）
    .loadDict(&#x27;names.txt&#x27;)          // 常见名词、人名
    .loadDict(&#x27;wildcard.txt&#x27;, &#x27;WILDCARD&#x27;, true)   // 通配符
    .loadSynonymDict(&#x27;synonym.txt&#x27;)   // 同义词
    .loadStopwordDict(&#x27;stopword.txt&#x27;) // 停止符
  ;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.version = require(&#x27;./package.json&#x27;).version;

/*
使用示例：

var segment = new Segment();
// 使用默认的识别模块及字典
segment.<span class="apidocCodeKeywordSpan">useDefault</span>();
// 开始分词
console.log(segment.doSegment(&#x27;这是一个基于Node.js的中文分词模块。&#x27;));

*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.SingleTokenizer" id="apidoc.module.segment.SingleTokenizer">module segment.SingleTokenizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.SingleTokenizer.init" id="apidoc.element.segment.SingleTokenizer.init">
        function <span class="apidocSignatureSpan">segment.SingleTokenizer.</span>init
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (segment) {
  exports.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!fs.existsSync(filename)) {
        throw Error(&#x27;Cannot find module &#x22;&#x27; + module + &#x27;&#x22;.&#x27;);
      } else {
        module = require(filename);
      }
    }
    // 初始化并注册模块
    module.<span class="apidocCodeKeywordSpan">init</span>(this);
    this.modules[module.type].push(module);
  }

  return this;
};

Segment.prototype._resolveDictFilename = function (name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.SingleTokenizer.split" id="apidoc.element.segment.SingleTokenizer.split">
        function <span class="apidocSignatureSpan">segment.SingleTokenizer.</span>split
        <span class="apidocSignatureSpan">(words)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (words) {
  var POSTAG = exports.segment.POSTAG;
  var ret = [];
  for (var i = 0, word; word = words[i]; i++) {
    if (word.p) {
      ret.push(word);
    } else {
      // 仅对未识别的词进行匹配
      ret = ret.concat(splitSingle(word.w));
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ret[i].ps = POSTAG.chsName(ret[i].p);
}
console.log(ret);
console.log(line);
console.log(&#x27;spent &#x27; + ((e - s) / NUM) + &#x27;ms&#x27;);
return;
console.log(segment.toString(ret));
var split = segment.<span class="apidocCodeKeywordSpan">split</span>(ret, &#x27;是&#x27;);
for (var i in split)
  console.log(segment.toString(split[i]));
console.log(segment.indexOf(ret, &#x27;的&#x27;, 3));
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.Tokenizer" id="apidoc.module.segment.Tokenizer">module segment.Tokenizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.Tokenizer.Tokenizer" id="apidoc.element.segment.Tokenizer.Tokenizer">
        function <span class="apidocSignatureSpan">segment.</span>Tokenizer
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Tokenizer = function (segment) {
  this.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.Tokenizer.prototype" id="apidoc.module.segment.Tokenizer.prototype">module segment.Tokenizer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.segment.Tokenizer.prototype.split" id="apidoc.element.segment.Tokenizer.prototype.split">
        function <span class="apidocSignatureSpan">segment.Tokenizer.prototype.</span>split
        <span class="apidocSignatureSpan">(text, modules)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (text, modules) {
  if (modules.length &#x3c; 1) {
    throw Error(&#x27;No tokenizer module!&#x27;);
  } else {
    // 按顺序分别调用各个module来进行分词 ： 各个module仅对没有识别类型的单词进行分词
    var ret = [{w: text}];
    modules.forEach(function (module) {
      ret = module.split(ret);
    });
    return ret;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ret[i].ps = POSTAG.chsName(ret[i].p);
}
console.log(ret);
console.log(line);
console.log(&#x27;spent &#x27; + ((e - s) / NUM) + &#x27;ms&#x27;);
return;
console.log(segment.toString(ret));
var split = segment.<span class="apidocCodeKeywordSpan">split</span>(ret, &#x27;是&#x27;);
for (var i in split)
  console.log(segment.toString(split[i]));
console.log(segment.indexOf(ret, &#x27;的&#x27;, 3));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.URLTokenizer" id="apidoc.module.segment.URLTokenizer">module segment.URLTokenizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.URLTokenizer.init" id="apidoc.element.segment.URLTokenizer.init">
        function <span class="apidocSignatureSpan">segment.URLTokenizer.</span>init
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (segment) {
  exports.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!fs.existsSync(filename)) {
        throw Error(&#x27;Cannot find module &#x22;&#x27; + module + &#x27;&#x22;.&#x27;);
      } else {
        module = require(filename);
      }
    }
    // 初始化并注册模块
    module.<span class="apidocCodeKeywordSpan">init</span>(this);
    this.modules[module.type].push(module);
  }

  return this;
};

Segment.prototype._resolveDictFilename = function (name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.URLTokenizer.split" id="apidoc.element.segment.URLTokenizer.split">
        function <span class="apidocSignatureSpan">segment.URLTokenizer.</span>split
        <span class="apidocSignatureSpan">(words)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (words) {
  var POSTAG = exports.segment.POSTAG;
  var ret = [];
  for (var i = 0, word; word = words[i]; i++) {
    if (word.p &#x3e; 0) {
      ret.push(word);
      continue;
    }
    // 仅对未识别的词进行匹配
    var urlinfo = matchURL(word.w);
    if (urlinfo.length &#x3c; 1) {
      ret.push(word);
      continue;
    }
    // 分离出URL
    var lastc = 0;
    for (var ui = 0, url; url = urlinfo[ui]; ui++) {
      if (url.c &#x3e; lastc) {
        ret.push({w: word.w.substr(lastc, url.c - lastc)});
      }
      ret.push({w: url.w, p: POSTAG.URL});
      lastc = url.c + url.w.length;
    }
    var lasturl = urlinfo[urlinfo.length - 1];
    if (lasturl.c + lasturl.w.length &#x3c; word.w.length) {
      ret.push({w: word.w.substr(lasturl.c + lasturl.w.length)});
    }
  }
  // debug(ret);
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ret[i].ps = POSTAG.chsName(ret[i].p);
}
console.log(ret);
console.log(line);
console.log(&#x27;spent &#x27; + ((e - s) / NUM) + &#x27;ms&#x27;);
return;
console.log(segment.toString(ret));
var split = segment.<span class="apidocCodeKeywordSpan">split</span>(ret, &#x27;是&#x27;);
for (var i in split)
  console.log(segment.toString(split[i]));
console.log(segment.indexOf(ret, &#x27;的&#x27;, 3));
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.segment.WildcardTokenizer" id="apidoc.module.segment.WildcardTokenizer">module segment.WildcardTokenizer</a></h1>


    <h2>
        <a href="#apidoc.element.segment.WildcardTokenizer.init" id="apidoc.element.segment.WildcardTokenizer.init">
        function <span class="apidocSignatureSpan">segment.WildcardTokenizer.</span>init
        <span class="apidocSignatureSpan">(segment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (segment) {
  exports.segment = segment;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!fs.existsSync(filename)) {
        throw Error(&#x27;Cannot find module &#x22;&#x27; + module + &#x27;&#x22;.&#x27;);
      } else {
        module = require(filename);
      }
    }
    // 初始化并注册模块
    module.<span class="apidocCodeKeywordSpan">init</span>(this);
    this.modules[module.type].push(module);
  }

  return this;
};

Segment.prototype._resolveDictFilename = function (name) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.segment.WildcardTokenizer.split" id="apidoc.element.segment.WildcardTokenizer.split">
        function <span class="apidocSignatureSpan">segment.WildcardTokenizer.</span>split
        <span class="apidocSignatureSpan">(words)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">split = function (words) {
  var POSTAG = exports.segment.POSTAG;
  var TABLE = exports.segment.getDict(&#x27;WILDCARD&#x27;);
  var ret = [];
  for (var i = 0, word; word = words[i]; i++) {
    if (word.p &#x3e; 0) {
      ret.push(word);
      continue;
    }
    // 仅对未识别的词进行匹配
    var wordinfo = matchWord(word.w);
    if (wordinfo.length &#x3c; 1) {
      ret.push(word);
      continue;
    }
    // 分离出已识别的单词
    var lastc = 0;
    for (var ui = 0, bw; bw = wordinfo[ui]; ui++) {
      if (bw.c &#x3e; lastc) {
        ret.push({w: word.w.substr(lastc, bw.c - lastc)});
      }
      ret.push({w: bw.w, p: TABLE[bw.w.toLowerCase()].p});
      lastc = bw.c + bw.w.length;
    }
    var lastword = wordinfo[wordinfo.length - 1];
    if (lastword.c + lastword.w.length &#x3c; word.w.length) {
      ret.push({w: word.w.substr(lastword.c + lastword.w.length)});
    }
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ret[i].ps = POSTAG.chsName(ret[i].p);
}
console.log(ret);
console.log(line);
console.log(&#x27;spent &#x27; + ((e - s) / NUM) + &#x27;ms&#x27;);
return;
console.log(segment.toString(ret));
var split = segment.<span class="apidocCodeKeywordSpan">split</span>(ret, &#x27;是&#x27;);
for (var i in split)
  console.log(segment.toString(split[i]));
console.log(segment.indexOf(ret, &#x27;的&#x27;, 3));
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
